use crate::analyzers::Analyzer;
use crate::types::{Finding, Severity};
use anyhow::Result;
use regex::Regex;
use std::path::Path;

/// AI content analyzer detects AI-generated placeholder content and incomplete implementations
pub struct AiContentAnalyzer {
    placeholder_patterns: Vec<Regex>,
    ai_comment_patterns: Vec<Regex>,
    generic_function_patterns: Vec<Regex>,
    incomplete_patterns: Vec<Regex>,
}

impl Default for AiContentAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}

impl AiContentAnalyzer {
    pub fn new() -> Self {
        Self {
            placeholder_patterns: vec![
                // Common AI placeholder text
                Regex::new(r"(?i)\b(add content here|implement this|your code here|placeholder|todo: implement)\b").unwrap(),
                Regex::new(r"(?i)\b(fill in the details|complete this|add your logic|insert code)\b").unwrap(),
                Regex::new(r"(?i)\b(replace with actual|modify as needed|customize this)\b").unwrap(),
                Regex::new(r"(?i)// (TODO|FIXME|HACK|XXX): (implement|add|complete|fix)").unwrap(),
                Regex::new(r"(?i)# (TODO|FIXME|HACK|XXX): (implement|add|complete|fix)").unwrap(),
            ],
            ai_comment_patterns: vec![
                // AI-generated comment markers
                Regex::new(r"(?i)// (generated by|created by|powered by) (ai|gpt|copilot|assistant)").unwrap(),
                Regex::new(r"(?i)# (generated by|created by|powered by) (ai|gpt|copilot|assistant)").unwrap(),
                Regex::new(r"(?i)/\* (generated by|created by|powered by) (ai|gpt|copilot|assistant)").unwrap(),
                Regex::new(r"(?i)<!-- (generated by|created by|powered by) (ai|gpt|copilot|assistant)").unwrap(),
            ],
            generic_function_patterns: vec![
                // Generic function names common in AI-generated code
                Regex::new(r"\bfn (do_something|handle_this|process_data|perform_action)\s*\(").unwrap(),
                Regex::new(r"\bfunction (doSomething|handleThis|processData|performAction)\s*\(").unwrap(),
                Regex::new(r"\bdef (do_something|handle_this|process_data|perform_action)\s*\(").unwrap(),
                Regex::new(r"\b(public|private|protected)?\s*(void|int|string|bool)?\s+(doSomething|handleThis|processData|performAction)\s*\(").unwrap(),
            ],
            incomplete_patterns: vec![
                // Patterns indicating incomplete implementations
                Regex::new(r"(?i)\b(not implemented|unimplemented|todo|fixme)\s*[!;]").unwrap(),
                Regex::new(r"\bunimplemented!\(\)").unwrap(),
                Regex::new(r#"\bpanic!\s*\(\s*\"not implemented\"\s*\)"#).unwrap(),
                Regex::new(r"\bthrow new NotImplementedException").unwrap(),
                Regex::new(r"\braise NotImplementedError").unwrap(),
                Regex::new(r"(?i)// stub|# stub|/\* stub").unwrap(),
            ],
        }
    }

    /// Add custom placeholder patterns
    pub fn with_custom_patterns(mut self, patterns: Vec<String>) -> Result<Self> {
        for pattern in patterns {
            match Regex::new(&pattern) {
                Ok(regex) => self.placeholder_patterns.push(regex),
                Err(e) => return Err(anyhow::anyhow!("Invalid regex pattern '{}': {}", pattern, e)),
            }
        }
        Ok(self)
    }

    /// Detect AI-generated placeholder content
    fn detect_placeholders(&self, content: &str, file_path: &Path) -> Vec<Finding> {
        let mut findings = Vec::new();

        for (line_num, line) in content.lines().enumerate() {
            let line_number = (line_num + 1) as u32;

            // Skip if this is likely a legitimate comment or documentation
            if self.is_legitimate_documentation(line) {
                continue;
            }

            for pattern in &self.placeholder_patterns {
                if pattern.is_match(line) {
                    findings.push(
                        Finding::new(
                            "ai_content",
                            "placeholder_content",
                            Severity::Medium,
                            file_path.to_path_buf(),
                            line_number,
                            "AI-generated placeholder content detected".to_string(),
                        )
                        .with_description(format!("Line contains placeholder text that may indicate incomplete AI-generated code: '{}'", line.trim()))
                        .with_suggestion("Replace placeholder content with actual implementation or remove if not needed".to_string()),
                    );
                }
            }
        }

        findings
    }

    /// Detect AI comment markers
    fn detect_ai_comments(&self, content: &str, file_path: &Path) -> Vec<Finding> {
        let mut findings = Vec::new();

        for (line_num, line) in content.lines().enumerate() {
            let line_number = (line_num + 1) as u32;

            for pattern in &self.ai_comment_patterns {
                if pattern.is_match(line) {
                    findings.push(
                        Finding::new(
                            "ai_content",
                            "ai_generated_marker",
                            Severity::Info,
                            file_path.to_path_buf(),
                            line_number,
                            "AI-generated content marker detected".to_string(),
                        )
                        .with_description("Line contains a marker indicating AI-generated content".to_string())
                        .with_suggestion("Review AI-generated code for correctness and security before production use".to_string()),
                    );
                }
            }
        }

        findings
    }

    /// Detect generic function names
    fn detect_generic_functions(&self, content: &str, file_path: &Path) -> Vec<Finding> {
        let mut findings = Vec::new();

        for (line_num, line) in content.lines().enumerate() {
            let line_number = (line_num + 1) as u32;

            // Skip test files and examples
            if self.is_test_or_example_file(file_path) {
                continue;
            }

            for pattern in &self.generic_function_patterns {
                if pattern.is_match(line) {
                    findings.push(
                        Finding::new(
                            "ai_content",
                            "generic_function_name",
                            Severity::Low,
                            file_path.to_path_buf(),
                            line_number,
                            "Generic function name detected".to_string(),
                        )
                        .with_description("Function has a generic name commonly used in AI-generated code templates".to_string())
                        .with_suggestion("Consider using more descriptive function names that reflect the actual purpose".to_string()),
                    );
                }
            }
        }

        findings
    }

    /// Detect incomplete implementations
    fn detect_incomplete_implementations(&self, content: &str, file_path: &Path) -> Vec<Finding> {
        let mut findings = Vec::new();

        for (line_num, line) in content.lines().enumerate() {
            let line_number = (line_num + 1) as u32;

            for pattern in &self.incomplete_patterns {
                if pattern.is_match(line) {
                    let severity = if line.contains("unimplemented!") || line.contains("NotImplementedException") {
                        Severity::High
                    } else {
                        Severity::Medium
                    };

                    findings.push(
                        Finding::new(
                            "ai_content",
                            "incomplete_implementation",
                            severity,
                            file_path.to_path_buf(),
                            line_number,
                            "Incomplete implementation detected".to_string(),
                        )
                        .with_description("Code contains markers indicating incomplete or unfinished implementation".to_string())
                        .with_suggestion("Complete the implementation before deploying to production".to_string()),
                    );
                }
            }
        }

        findings
    }

    /// Check if line is legitimate documentation
    fn is_legitimate_documentation(&self, line: &str) -> bool {
        let trimmed = line.trim();
        
        // Skip documentation comments
        if trimmed.starts_with("///") || trimmed.starts_with("//!") {
            return true;
        }
        
        // Skip markdown documentation
        if trimmed.starts_with("# ") || trimmed.starts_with("## ") || trimmed.starts_with("### ") {
            return true;
        }
        
        // Skip JSDoc or similar
        if trimmed.starts_with("/**") || trimmed.starts_with("* ") {
            return true;
        }

        false
    }

    /// Check if file is a test or example file
    fn is_test_or_example_file(&self, file_path: &Path) -> bool {
        let path_str = file_path.to_string_lossy().to_lowercase();
        
        // Check for test directories or files
        if path_str.contains("/test") || path_str.contains("\\test") ||
           path_str.contains("/tests") || path_str.contains("\\tests") ||
           path_str.contains("_test.") || path_str.contains(".test.") ||
           path_str.contains("/example") || path_str.contains("\\example") ||
           path_str.contains("/examples") || path_str.contains("\\examples") ||
           path_str.contains("_example.") || path_str.contains(".example.") {
            return true;
        }

        // Check filename
        if let Some(filename) = file_path.file_name().and_then(|n| n.to_str()) {
            let filename_lower = filename.to_lowercase();
            if filename_lower.starts_with("test_") || 
               filename_lower.starts_with("example_") ||
               filename_lower.ends_with("_test.rs") ||
               filename_lower.ends_with("_example.rs") ||
               filename_lower == "tests.rs" ||
               filename_lower == "examples.rs" {
                return true;
            }
        }

        false
    }

    /// Check if file should be skipped from AI content analysis
    fn should_skip_file(&self, file_path: &Path) -> bool {
        // Skip certain file types that commonly contain placeholder text legitimately
        if let Some(ext) = file_path.extension().and_then(|e| e.to_str()) {
            match ext.to_lowercase().as_str() {
                "md" | "txt" | "rst" | "adoc" => return true, // Documentation files
                "template" | "tmpl" | "tpl" => return true,    // Template files
                _ => {}
            }
        }

        // Skip configuration and template directories
        let path_str = file_path.to_string_lossy().to_lowercase();
        if path_str.contains("/template") || path_str.contains("\\template") ||
           path_str.contains("/templates") || path_str.contains("\\templates") ||
           path_str.contains("/.github") || path_str.contains("\\.github") {
            return true;
        }

        false
    }
}

impl Analyzer for AiContentAnalyzer {
    fn name(&self) -> &str {
        "ai_content"
    }

    fn analyze(&self, file_path: &Path, content: &[u8]) -> Result<Vec<Finding>> {
        if self.should_skip_file(file_path) {
            return Ok(Vec::new());
        }

        let content_str = String::from_utf8_lossy(content);
        let mut findings = Vec::new();

        // Detect various types of AI-generated content
        findings.extend(self.detect_placeholders(&content_str, file_path));
        findings.extend(self.detect_ai_comments(&content_str, file_path));
        findings.extend(self.detect_generic_functions(&content_str, file_path));
        findings.extend(self.detect_incomplete_implementations(&content_str, file_path));

        Ok(findings)
    }

    fn supports_file(&self, file_path: &Path) -> bool {
        // Support most text-based source code files
        if let Some(ext) = file_path.extension().and_then(|e| e.to_str()) {
            matches!(
                ext.to_lowercase().as_str(),
                "rs" | "js" | "ts" | "py" | "java" | "cpp" | "c" | "h" | "hpp" | 
                "go" | "php" | "rb" | "cs" | "swift" | "kt" | "scala" | "dart" |
                "html" | "css" | "scss" | "less" | "vue" | "jsx" | "tsx" |
                "json" | "yaml" | "yml" | "toml" | "xml" | "sql"
            )
        } else {
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_detect_placeholder_content() {
        let analyzer = AiContentAnalyzer::new();
        let content = r#"
fn main() {
    // TODO: implement this function
    println!("add content here");
}
"#;
        let findings = analyzer.analyze(Path::new("test.rs"), content.as_bytes()).unwrap();
        assert!(findings.iter().any(|f| f.rule_id == "placeholder_content"));
    }

    #[test]
    fn test_detect_ai_comments() {
        let analyzer = AiContentAnalyzer::new();
        let content = r#"
// Generated by AI assistant
fn example() {
    println!("Hello");
}
"#;
        let findings = analyzer.analyze(Path::new("test.rs"), content.as_bytes()).unwrap();
        assert!(findings.iter().any(|f| f.rule_id == "ai_generated_marker"));
    }

    #[test]
    fn test_detect_generic_functions() {
        let analyzer = AiContentAnalyzer::new();
        let content = r#"
fn do_something() {
    println!("Generic function");
}
"#;
        let findings = analyzer.analyze(Path::new("test.rs"), content.as_bytes()).unwrap();
        assert!(findings.iter().any(|f| f.rule_id == "generic_function_name"));
    }

    #[test]
    fn test_detect_incomplete_implementations() {
        let analyzer = AiContentAnalyzer::new();
        let content = r#"
fn incomplete() {
    unimplemented!()
}
"#;
        let findings = analyzer.analyze(Path::new("test.rs"), content.as_bytes()).unwrap();
        assert!(findings.iter().any(|f| f.rule_id == "incomplete_implementation"));
    }

    #[test]
    fn test_skip_test_files() {
        let analyzer = AiContentAnalyzer::new();
        let content = r#"
fn do_something() {
    // This is in a test file, should be ignored
}
"#;
        let findings = analyzer.analyze(Path::new("tests/test_example.rs"), content.as_bytes()).unwrap();
        // Generic function names should be ignored in test files
        assert!(!findings.iter().any(|f| f.rule_id == "generic_function_name"));
    }

    #[test]
    fn test_skip_documentation_files() {
        let analyzer = AiContentAnalyzer::new();
        let content = "# TODO: implement this feature\nAdd content here for documentation.";
        let findings = analyzer.analyze(Path::new("README.md"), content.as_bytes()).unwrap();
        assert_eq!(findings.len(), 0); // Should skip .md files
    }

    #[test]
    fn test_supports_file() {
        let analyzer = AiContentAnalyzer::new();
        assert!(analyzer.supports_file(Path::new("test.rs")));
        assert!(analyzer.supports_file(Path::new("test.js")));
        assert!(analyzer.supports_file(Path::new("test.py")));
        assert!(!analyzer.supports_file(Path::new("test.exe")));
        assert!(!analyzer.supports_file(Path::new("test.png")));
    }

    #[test]
    fn test_custom_patterns() {
        let custom_patterns = vec!["custom placeholder".to_string()];
        let analyzer = AiContentAnalyzer::new().with_custom_patterns(custom_patterns).unwrap();
        let content = "This is a custom placeholder in the code";
        let findings = analyzer.analyze(Path::new("test.rs"), content.as_bytes()).unwrap();
        assert!(findings.iter().any(|f| f.rule_id == "placeholder_content"));
    }
}