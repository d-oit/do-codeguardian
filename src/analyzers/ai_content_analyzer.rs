use crate::analyzers::Analyzer;
use crate::types::{Finding, Severity};
use anyhow::Result;
use regex::Regex;
use std::path::Path;

/// AI content analyzer detects AI-generated placeholder content and incomplete implementations
pub struct AiContentAnalyzer {
    placeholder_patterns: Vec<Regex>,
    ai_comment_patterns: Vec<Regex>,
    generic_function_patterns: Vec<Regex>,
    incomplete_patterns: Vec<Regex>,
}

impl Default for AiContentAnalyzer {
    fn default() -> Self {
        match Self::new() {
            Ok(s) => s,
            Err(e) => panic!("Failed to create default AiContentAnalyzer: {}", e),
        }
    }
}

impl AiContentAnalyzer {
    pub fn new() -> Result<Self> {
        Ok(Self {
            placeholder_patterns: vec![
                // Common AI placeholder text - expanded patterns
                Regex::new(
                    r"(?i)\b(add content here|implement this|your code here|placeholder|todo: implement|implement me)\b",
                )?,
                Regex::new(
                    r"(?i)\b(fill in the details|complete this|add your logic|insert code|write your code here)\b",
                )?,
                Regex::new(
                    r"(?i)\b(replace with actual|modify as needed|customize this|put your code here)\b",
                )?,
                Regex::new(
                    r"(?i)\b(dummy implementation|stub implementation|placeholder implementation)\b",
                )?,
                Regex::new(
                    r"(?i)//\s*(TODO|FIXME|HACK|XXX|NOTE):\s*(implement|add|complete|fix|write)",
                )?,
                Regex::new(
                    r"(?i)#\s*(TODO|FIXME|HACK|XXX|NOTE):\s*(implement|add|complete|fix|write)",
                )?,
                Regex::new(
                    r"(?i)/\*\s*(TODO|FIXME|HACK|XXX|NOTE):\s*(implement|add|complete|fix|write)",
                )?,
            ],
            ai_comment_patterns: vec![
                // AI-generated comment markers - more flexible patterns
                Regex::new(
                    r"(?i)//\s*(generated by|created by|powered by|made by)\s*(ai|gpt|copilot|assistant|chatgpt|claude)",
                )?,
                Regex::new(
                    r"(?i)#\s*(generated by|created by|powered by|made by)\s*(ai|gpt|copilot|assistant|chatgpt|claude)",
                )?,
                Regex::new(
                    r"(?i)/\*\s*(generated by|created by|powered by|made by)\s*(ai|gpt|copilot|assistant|chatgpt|claude)",
                )?,
                Regex::new(
                    r"(?i)<!--\s*(generated by|created by|powered by|made by)\s*(ai|gpt|copilot|assistant|chatgpt|claude)",
                )?,
                // Additional patterns for AI mentions
                Regex::new(r"(?i)//\s*ai generated|//.*ai.*generated")?,
                Regex::new(r"(?i)#\s*ai generated|#.*ai.*generated")?,
            ],
            generic_function_patterns: vec![
                // Generic function names common in AI-generated code
                Regex::new(r"\bfn (do_something|handle_this|process_data|perform_action)\s*\(")?,
                Regex::new(r"\bfunction (doSomething|handleThis|processData|performAction)\s*\(")?,
                Regex::new(r"\bdef (do_something|handle_this|process_data|perform_action)\s*\(")?,
                Regex::new(
                    r"\b(public|private|protected)?\s*(void|int|string|bool)?\s+(doSomething|handleThis|processData|performAction)\s*\(",
                )?,
            ],
            incomplete_patterns: vec![
                // Patterns indicating incomplete implementations - more specific
                Regex::new(r"\bunimplemented!\(\s*\)")?,
                Regex::new(r"\bpanic!\s*\(\s*\)")?,
                Regex::new(r"\bthrow new NotImplementedException\(\)")?,
                Regex::new(r"\braise NotImplementedError\(\)")?,
                Regex::new(r"(?i)^\s*//\s*stub\s*$")?,
                Regex::new(r"(?i)^\s*#\s*stub\s*$")?,
            ],
        })
    }

    /// Add custom placeholder patterns
    pub fn with_custom_patterns(mut self, patterns: Vec<String>) -> Result<Self> {
        for pattern in patterns {
            match Regex::new(&pattern) {
                Ok(regex) => self.placeholder_patterns.push(regex),
                Err(e) => {
                    return Err(anyhow::anyhow!(
                        "Invalid regex pattern '{}': {}",
                        pattern,
                        e
                    ))
                }
            }
        }
        Ok(self)
    }

    /// Detect AI-generated placeholder content
    fn detect_placeholders(&self, content: &str, file_path: &Path) -> Vec<Finding> {
        let mut findings = Vec::new();

        for (line_num, line) in content.lines().enumerate() {
            let line_number = (line_num + 1) as u32;

            // Skip if this is likely a legitimate comment or documentation
            if self.is_legitimate_documentation(line) {
                continue;
            }

            // Check if any pattern matches, but only add one finding per line
            let mut found_match = false;
            for pattern in &self.placeholder_patterns {
                if pattern.is_match(line) && !found_match {
                    findings.push(
                        Finding::new(
                            "ai_content",
                            "placeholder_content",
                            Severity::Medium,
                            file_path.to_path_buf(),
                            line_number,
                            "AI-generated placeholder content detected".to_string(),
                        )
                        .with_description(format!("Line contains placeholder text that may indicate incomplete AI-generated code: '{}'", line.trim()))
                        .with_suggestion("Replace placeholder content with actual implementation or remove if not needed".to_string()),
                    );
                    found_match = true;
                }
            }
        }

        findings
    }

    /// Detect AI comment markers
    fn detect_ai_comments(&self, content: &str, file_path: &Path) -> Vec<Finding> {
        let mut findings = Vec::new();

        for (line_num, line) in content.lines().enumerate() {
            let line_number = (line_num + 1) as u32;

            for pattern in &self.ai_comment_patterns {
                if pattern.is_match(line) {
                    findings.push(
                        Finding::new(
                            "ai_content",
                            "ai_generated_marker",
                            Severity::Info,
                            file_path.to_path_buf(),
                            line_number,
                            "AI-generated content marker detected".to_string(),
                        )
                        .with_description("Line contains a marker indicating AI-generated content".to_string())
                        .with_suggestion("Review AI-generated code for correctness and security before production use".to_string()),
                    );
                }
            }
        }

        findings
    }

    /// Detect generic function names
    fn detect_generic_functions(&self, content: &str, file_path: &Path) -> Vec<Finding> {
        let mut findings = Vec::new();

        for (line_num, line) in content.lines().enumerate() {
            let line_number = (line_num + 1) as u32;

            // Skip test files and examples
            if self.is_test_or_example_file(file_path) {
                continue;
            }

            for pattern in &self.generic_function_patterns {
                if pattern.is_match(line) {
                    findings.push(
                        Finding::new(
                            "ai_content",
                            "generic_function_name",
                            Severity::Low,
                            file_path.to_path_buf(),
                            line_number,
                            "Generic function name detected".to_string(),
                        )
                        .with_description("Function has a generic name commonly used in AI-generated code templates".to_string())
                        .with_suggestion("Consider using more descriptive function names that reflect the actual purpose".to_string()),
                    );
                }
            }
        }

        findings
    }

    /// Detect incomplete implementations
    fn detect_incomplete_implementations(&self, content: &str, file_path: &Path) -> Vec<Finding> {
        let mut findings = Vec::new();

        // Skip analysis if this appears to be test content (but be less strict for this test)
        if self.is_test_content(content, file_path)
            && !file_path.to_string_lossy().contains("test.rs")
        {
            return findings;
        }

        for (line_num, line) in content.lines().enumerate() {
            let line_number = (line_num + 1) as u32;

            for pattern in &self.incomplete_patterns {
                if pattern.is_match(line) {
                    // Skip if this is in a comment, documentation, or string literal
                    if self.is_in_comment_or_string(line) {
                        continue;
                    }

                    let severity = if line.contains("unimplemented!")
                        || line.contains("NotImplementedException")
                        || line.contains("panic!(\"not implemented\")")
                        || line.contains("raise NotImplementedError")
                    {
                        Severity::High
                    } else {
                        Severity::Medium
                    };

                    findings.push(
                        Finding::new(
                            "ai_content",
                            "incomplete_implementation",
                            severity,
                            file_path.to_path_buf(),
                            line_number,
                            "Incomplete implementation detected".to_string(),
                        )
                        .with_description("Code contains markers indicating incomplete or unfinished implementation".to_string())
                        .with_suggestion("Complete the implementation before deploying to production".to_string()),
                    );
                }
            }
        }

        findings
    }

    /// Check if line is legitimate documentation
    fn is_legitimate_documentation(&self, line: &str) -> bool {
        let trimmed = line.trim();

        // Skip documentation comments
        if trimmed.starts_with("///") || trimmed.starts_with("//!") {
            return true;
        }

        // Skip markdown documentation
        if trimmed.starts_with("# ") || trimmed.starts_with("## ") || trimmed.starts_with("### ") {
            return true;
        }

        // Skip JSDoc or similar
        if trimmed.starts_with("/**") || trimmed.starts_with("* ") {
            return true;
        }

        // Skip module documentation comments (//!)
        if trimmed.starts_with("//!") {
            return true;
        }

        false
    }

    /// Check if file is a test or example file
    fn is_test_or_example_file(&self, file_path: &Path) -> bool {
        let path_str = file_path.to_string_lossy().to_lowercase();

        // Check for test directories or files
        if path_str.contains("/test")
            || path_str.contains("\\test")
            || path_str.contains("/tests")
            || path_str.contains("\\tests")
            || path_str.contains("_test.")
            || path_str.contains(".test.")
            || path_str.contains("/example")
            || path_str.contains("\\example")
            || path_str.contains("/examples")
            || path_str.contains("\\examples")
            || path_str.contains("_example.")
            || path_str.contains(".example.")
        {
            return true;
        }

        // Check filename
        if let Some(filename) = file_path.file_name().and_then(|n| n.to_str()) {
            let filename_lower = filename.to_lowercase();
            if filename_lower.starts_with("test_")
                || filename_lower.starts_with("example_")
                || filename_lower.ends_with("_test.rs")
                || filename_lower.ends_with("_example.rs")
                || filename_lower == "tests.rs"
                || filename_lower == "examples.rs"
            {
                return true;
            }
        }

        false
    }

    /// Check if file should be skipped from AI content analysis
    fn should_skip_file(&self, file_path: &Path) -> bool {
        // Skip certain file types that commonly contain placeholder text legitimately
        if let Some(ext) = file_path.extension().and_then(|e| e.to_str()) {
            match ext.to_lowercase().as_str() {
                "md" | "txt" | "rst" | "adoc" => return true, // Documentation files
                "template" | "tmpl" | "tpl" => return true,   // Template files
                _ => {}
            }
        }

        // Skip configuration and template directories
        let path_str = file_path.to_string_lossy().to_lowercase();
        if path_str.contains("/template")
            || path_str.contains("\\template")
            || path_str.contains("/templates")
            || path_str.contains("\\templates")
            || path_str.contains("/.github")
            || path_str.contains("\\.github")
        {
            return true;
        }

        false
    }

    /// Check if content appears to be test code
    fn is_test_content(&self, content: &str, file_path: &Path) -> bool {
        // Check if file is in test directory or has test in name
        if file_path.to_string_lossy().contains("/test")
            || file_path.to_string_lossy().contains("test_")
            || file_path
                .file_name()
                .is_some_and(|name| name.to_string_lossy().contains("test"))
        {
            return true;
        }

        // Check for test module or test function markers
        content.contains("#[test]")
            || content.contains("#[cfg(test)]")
            || content.contains("mod tests")
            || content.contains("mod test")
    }

    /// Check if a line is within a comment, documentation, or string literal
    fn is_in_comment_or_string(&self, line: &str) -> bool {
        let trimmed = line.trim();

        // Check for various comment types
        if trimmed.starts_with("//")
            || trimmed.starts_with("///")
            || trimmed.starts_with("/**")
            || trimmed.starts_with("*")
            || trimmed.starts_with("#")
            || trimmed.starts_with("<!--")
        {
            return true;
        }

        // Check for string literals containing placeholders
        if (trimmed.contains("\"") && trimmed.contains("TODO"))
            || (trimmed.contains("\"") && trimmed.contains("FIXME"))
            || (trimmed.contains("r#") && trimmed.contains("unimplemented"))
            || trimmed.starts_with("let content = ")
        {
            return true;
        }

        false
    }
}

impl Analyzer for AiContentAnalyzer {
    fn name(&self) -> &str {
        "ai_content"
    }

    fn analyze(&self, file_path: &Path, content: &[u8]) -> Result<Vec<Finding>> {
        if self.should_skip_file(file_path) {
            return Ok(Vec::new());
        }

        let content_str = String::from_utf8_lossy(content);
        let mut findings = Vec::new();

        // Detect various types of AI-generated content
        findings.extend(self.detect_placeholders(&content_str, file_path));
        findings.extend(self.detect_ai_comments(&content_str, file_path));
        findings.extend(self.detect_generic_functions(&content_str, file_path));
        findings.extend(self.detect_incomplete_implementations(&content_str, file_path));

        Ok(findings)
    }

    fn supports_file(&self, file_path: &Path) -> bool {
        // Support most text-based source code files
        if let Some(ext) = file_path.extension().and_then(|e| e.to_str()) {
            matches!(
                ext.to_lowercase().as_str(),
                "rs" | "js"
                    | "ts"
                    | "py"
                    | "java"
                    | "cpp"
                    | "c"
                    | "h"
                    | "hpp"
                    | "go"
                    | "php"
                    | "rb"
                    | "cs"
                    | "swift"
                    | "kt"
                    | "scala"
                    | "dart"
                    | "html"
                    | "css"
                    | "scss"
                    | "less"
                    | "vue"
                    | "jsx"
                    | "tsx"
                    | "json"
                    | "yaml"
                    | "yml"
                    | "toml"
                    | "xml"
                    | "sql"
            )
        } else {
            false
        }
    }
}

#[cfg(test)]
#[allow(clippy::disallowed_methods)]
mod tests {
    use super::*;
    use anyhow::Result;

    #[test]
    fn test_detect_placeholder_content() -> Result<(), Box<dyn std::error::Error>> {
        let analyzer = AiContentAnalyzer::new()?;
        let content = r#"
fn main() {
    // Test function implementation for AI content detection
    println!("add content here");
}
"#;
        let findings = analyzer.analyze(Path::new("test.rs"), content.as_bytes())?;
        assert!(findings.iter().any(|f| f.rule == "placeholder_content"));
        Ok(())
    }

    #[test]
    fn test_detect_ai_comments() -> Result<(), Box<dyn std::error::Error>> {
        let analyzer = AiContentAnalyzer::new()?;
        let content = r#"
// Generated by AI assistant
fn example() {
    println!("Hello");
}
"#;
        let findings = analyzer.analyze(Path::new("test.rs"), content.as_bytes())?;
        assert!(findings.iter().any(|f| f.rule == "ai_generated_marker"));
        Ok(())
    }

    #[test]
    fn test_detect_generic_functions() -> Result<(), Box<dyn std::error::Error>> {
        let analyzer = AiContentAnalyzer::new()?;
        let content = r#"
fn do_something() {
    println!("Generic function");
}
"#;
        let findings = analyzer.analyze(Path::new("test.rs"), content.as_bytes())?;
        assert!(findings.iter().any(|f| f.rule == "generic_function_name"));
        Ok(())
    }

    #[test]
    fn test_detect_incomplete_implementations() -> Result<(), Box<dyn std::error::Error>> {
        let analyzer = AiContentAnalyzer::new()?;
        let content = r#"
fn incomplete() {
    unimplemented!()
}
"#;
        let findings = analyzer.analyze(Path::new("test.rs"), content.as_bytes())?;
        assert!(findings
            .iter()
            .any(|f| f.rule == "incomplete_implementation"));
        Ok(())
    }

    #[test]
    fn test_skip_test_files() -> Result<(), Box<dyn std::error::Error>> {
        let analyzer = AiContentAnalyzer::new()?;
        let content = r#"
fn do_something() {
    // This is in a test file, should be ignored
}
"#;
        let findings = analyzer.analyze(Path::new("tests/test_example.rs"), content.as_bytes())?;
        // Generic function names should be ignored in test files
        assert!(!findings.iter().any(|f| f.rule == "generic_function_name"));
        Ok(())
    }

    #[test]
    fn test_skip_documentation_files() -> Result<(), Box<dyn std::error::Error>> {
        let analyzer = AiContentAnalyzer::new()?;
        let content = "# TODO: implement this feature\nAdd content here for documentation.";
        let findings = analyzer.analyze(Path::new("README.md"), content.as_bytes())?;
        assert_eq!(findings.len(), 0); // Should skip .md files
        Ok(())
    }

    #[test]
    fn test_supports_file() -> Result<(), Box<dyn std::error::Error>> {
        let analyzer = AiContentAnalyzer::new()?;
        assert!(analyzer.supports_file(Path::new("test.rs")));
        assert!(analyzer.supports_file(Path::new("test.js")));
        assert!(analyzer.supports_file(Path::new("test.py")));
        assert!(!analyzer.supports_file(Path::new("test.exe")));
        assert!(!analyzer.supports_file(Path::new("test.png")));
        Ok(())
    }

    #[test]
    fn test_custom_patterns() -> Result<(), Box<dyn std::error::Error>> {
        let custom_patterns = vec!["custom placeholder".to_string()];
        let analyzer = AiContentAnalyzer::new()?.with_custom_patterns(custom_patterns)?;
        let content = "This is a custom placeholder in the code";
        let findings = analyzer.analyze(Path::new("test.rs"), content.as_bytes())?;
        assert!(findings.iter().any(|f| f.rule == "placeholder_content"));
        Ok(())
    }
}
