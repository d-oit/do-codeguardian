use do_codeguardian::analyzers::{
    ai_content_analyzer::AiContentAnalyzer, duplicate_analyzer::DuplicateAnalyzer,
    git_conflict_analyzer::GitConflictAnalyzer, Analyzer,
};
use do_codeguardian::types::Severity;
use std::path::Path;

#[cfg(test)]
mod git_conflict_tests {
    use super::*;

    #[test]
    fn test_complete_merge_conflict_detection() {
        let analyzer = GitConflictAnalyzer::new();
        let content = r#"
fn main() {
    println!("Starting application");

<<<<<<< HEAD
    let version = "1.0.0";
    println!("Version: {}", version);
=======
    let version = "2.0.0";
    println!("App version: {}", version);
>>>>>>> feature-branch

    println!("Application started");
}
"#;

        let findings = analyzer
            .analyze(Path::new("test.rs"), content.as_bytes())
            .unwrap();

        // Should detect start, separator, and end markers
        assert_eq!(findings.len(), 3);
        assert!(findings.iter().any(|f| f.rule == "merge_conflict_start"));
        assert!(findings
            .iter()
            .any(|f| f.rule == "merge_conflict_separator"));
        assert!(findings.iter().any(|f| f.rule == "merge_conflict_end"));

        // All conflict findings should be critical severity
        for finding in &findings {
            assert_eq!(finding.severity, Severity::Critical);
            assert_eq!(finding.analyzer, "git_conflict");
        }
    }

    #[test]
    fn test_malformed_conflict_detection() {
        let analyzer = GitConflictAnalyzer::new();
        let content = r#"
fn main() {
<<<<<<< HEAD
    let x = 1;
=======
    let x = 2;
    // Missing end marker
}
"#;

        let findings = analyzer
            .analyze(Path::new("test.rs"), content.as_bytes())
            .unwrap();

        // Should detect malformed conflict
        assert!(findings.iter().any(|f| f.rule == "malformed_conflict"));
        assert!(findings.iter().any(|f| f.severity == Severity::Critical));
    }

    #[test]
    fn test_json_syntax_validation() {
        let analyzer = GitConflictAnalyzer::new();
        let invalid_json = r#"{"key": "value", "incomplete": "#; // Missing closing

        let findings = analyzer
            .analyze(Path::new("test.json"), invalid_json.as_bytes())
            .unwrap();

        assert!(findings.iter().any(|f| f.rule == "syntax_error"));
        assert!(findings.iter().any(|f| f.severity == Severity::High));
    }

    #[test]
    fn test_no_conflicts_clean_file() {
        let analyzer = GitConflictAnalyzer::new();
        let clean_content = r#"
fn main() {
    println!("Clean code with no conflicts");
    let version = "1.0.0";
}
"#;

        let findings = analyzer
            .analyze(Path::new("test.rs"), clean_content.as_bytes())
            .unwrap();
        assert_eq!(findings.len(), 0);
    }

    #[test]
    fn test_file_type_support() {
        let analyzer = GitConflictAnalyzer::new();

        // Should support text files
        assert!(analyzer.supports_file(Path::new("test.rs")));
        assert!(analyzer.supports_file(Path::new("test.js")));
        assert!(analyzer.supports_file(Path::new("test.json")));
        assert!(analyzer.supports_file(Path::new("README.md")));

        // Should not support binary files
        assert!(!analyzer.supports_file(Path::new("test.exe")));
        assert!(!analyzer.supports_file(Path::new("test.png")));
        assert!(!analyzer.supports_file(Path::new("test.jpg")));
    }
}

#[cfg(test)]
mod ai_content_tests {
    use super::*;

    #[test]
    fn test_placeholder_detection() {
        let analyzer = AiContentAnalyzer::new();
        let content = r#"
fn main() {
    // TODO: implement this function
    println!("add content here");

    // This needs to be completed
    placeholder_function();
}

fn placeholder_function() {
    // implement this later
    unimplemented!()
}
"#;

        let findings = analyzer
            .analyze(Path::new("test.rs"), content.as_bytes())
            .unwrap();

        // Should detect multiple placeholder patterns
        assert!(!findings.is_empty());
        assert!(findings.iter().any(|f| f.rule == "placeholder_content"));
        assert!(findings
            .iter()
            .any(|f| f.rule == "incomplete_implementation"));
    }

    #[test]
    fn test_ai_comment_detection() {
        let analyzer = AiContentAnalyzer::new();
        let content = r#"
// Generated by AI assistant
fn example_function() {
    println!("This was created by GPT");
}

/* Created by Copilot */
fn another_function() {
    // Powered by AI
}
"#;

        let findings = analyzer
            .analyze(Path::new("test.rs"), content.as_bytes())
            .unwrap();

        assert!(findings.iter().any(|f| f.rule == "ai_generated_marker"));
        assert!(findings.iter().any(|f| f.severity == Severity::Info));
    }

    #[test]
    fn test_generic_function_detection() {
        let analyzer = AiContentAnalyzer::new();
        let content = r#"
fn do_something() {
    println!("Generic function name");
}

fn handle_this(data: &str) {
    process_data(data);
}

fn process_data(input: &str) {
    // Generic processing
}
"#;

        let findings = analyzer
            .analyze(Path::new("src/main.rs"), content.as_bytes())
            .unwrap();

        // Should detect generic function names (but not in test files)
        assert!(findings.iter().any(|f| f.rule == "generic_function_name"));
        assert!(findings.iter().any(|f| f.severity == Severity::Low));
    }

    #[test]
    fn test_skip_test_files() {
        let analyzer = AiContentAnalyzer::new();
        let content = r#"
fn do_something() {
    // This is in a test file, should be ignored for generic names
}
"#;

        let findings = analyzer
            .analyze(Path::new("tests/test_example.rs"), content.as_bytes())
            .unwrap();

        // Generic function names should be ignored in test files
        assert!(!findings.iter().any(|f| f.rule == "generic_function_name"));
    }

    #[test]
    fn test_skip_documentation_files() {
        let analyzer = AiContentAnalyzer::new();
        let content = "# TODO: implement this feature\nAdd content here for documentation.";

        let findings = analyzer
            .analyze(Path::new("README.md"), content.as_bytes())
            .unwrap();

        // Should skip .md files entirely
        assert_eq!(findings.len(), 0);
    }

    #[test]
    fn test_custom_patterns() {
        let custom_patterns = vec!["custom placeholder".to_string(), "fix me later".to_string()];
        let analyzer = AiContentAnalyzer::new()
            .with_custom_patterns(custom_patterns)
            .unwrap();

        let content = r#"
fn main() {
    // This is a custom placeholder in the code
    println!("fix me later");
}
"#;

        let findings = analyzer
            .analyze(Path::new("test.rs"), content.as_bytes())
            .unwrap();

        assert!(findings.iter().any(|f| f.rule == "placeholder_content"));
    }

    #[test]
    fn test_incomplete_implementation_severity() {
        let analyzer = AiContentAnalyzer::new();
        let content = r#"
fn critical_unimplemented() {
    unimplemented!()
}

fn todo_implementation() {
    // TODO: implement this
}
"#;

        let findings = analyzer
            .analyze(Path::new("test.rs"), content.as_bytes())
            .unwrap();

        // unimplemented! should be high severity
        let unimpl_finding = findings
            .iter()
            .find(|f| f.rule == "incomplete_implementation" && f.line == 3)
            .unwrap();
        assert_eq!(unimpl_finding.severity, Severity::High);

        // TODO should be medium severity
        let todo_finding = findings.iter().find(|f| f.rule == "placeholder_content");
        if let Some(finding) = todo_finding {
            assert_eq!(finding.severity, Severity::Medium);
        }
    }
}

#[cfg(test)]
mod duplicate_analyzer_tests {
    use super::*;

    #[test]
    fn test_internal_duplicate_detection() {
        let analyzer = DuplicateAnalyzer::new().with_min_lines(3);
        let content = r#"
fn authenticate_user(username: &str, password: &str) -> bool {
    let hashed = hash_password(password);
    let stored = get_stored_password(username);
    let result = hashed == stored;
    log_authentication_attempt(username, result);
    result
}

fn authenticate_admin(username: &str, password: &str) -> bool {
    let hashed = hash_password(password);
    let stored = get_stored_password(username);
    let result = hashed == stored;
    log_authentication_attempt(username, result);
    result
}

fn hash_password(password: &str) -> String {
    format!("hashed_{}", password)
}

fn get_stored_password(username: &str) -> String {
    format!("stored_{}", username)
}

fn log_authentication_attempt(username: &str, success: bool) {
    println!("Auth attempt for {}: {}", username, success);
}
"#;

        let findings = analyzer
            .analyze(Path::new("auth.rs"), content.as_bytes())
            .unwrap();

        // Should detect duplicate authentication functions
        assert!(findings.iter().any(|f| f.rule == "internal_duplication"));

        // Should be high severity due to security relevance
        let duplicate_finding = findings
            .iter()
            .find(|f| f.rule == "internal_duplication")
            .unwrap();
        assert!(matches!(
            duplicate_finding.severity,
            Severity::High | Severity::Medium
        ));
    }

    #[test]
    fn test_security_relevance_detection() {
        let analyzer = DuplicateAnalyzer::new();

        // Security-relevant code block
        //        let security_block = do_codeguardian::analyzers::duplicate_analyzer::CodeBlock {
        //            lines: vec!["authenticate_user".to_string(), "hash_password".to_string()],
        //            start_line: 1,
        //            end_line: 2,
        //        };
        //
        //        // Non-security code block
        //        let normal_block = do_codeguardian::analyzers::duplicate_analyzer::CodeBlock {
        //            lines: vec!["println!".to_string(), "format!".to_string()],
        //            start_line: 1,
        //            end_line: 2,
        //        };

        // Note: This test would require exposing the is_security_relevant method
        // For now, we'll test through the full analysis
        let security_content = r#"
fn authenticate_user() {
    // Security function
}
fn authenticate_user_copy() {
    // Security function
}
"#;

        let _findings = analyzer
            .analyze(Path::new("security.rs"), security_content.as_bytes())
            .unwrap();
        // The analyzer should focus on security-relevant duplicates
    }

    #[test]
    fn test_ignore_test_files() {
        let analyzer = DuplicateAnalyzer::new();
        let content = r#"
fn test_duplicate_function() {
    assert_eq!(1, 1);
    assert_eq!(2, 2);
    assert_eq!(3, 3);
}

fn test_another_duplicate() {
    assert_eq!(1, 1);
    assert_eq!(2, 2);
    assert_eq!(3, 3);
}
"#;

        let findings = analyzer
            .analyze(Path::new("tests/test_auth.rs"), content.as_bytes())
            .unwrap();

        // Should ignore duplicates in test files by default
        assert_eq!(findings.len(), 0);
    }

    #[test]
    fn test_similarity_calculation() {
        let analyzer = DuplicateAnalyzer::new();

        // This test would require exposing the calculate_similarity method
        // For integration testing, we verify through actual analysis results
        let identical_content = r#"
fn function_a() {
    let x = 1;
    let y = 2;
    let z = x + y;
    println!("{}", z);
}

fn function_b() {
    let x = 1;
    let y = 2;
    let z = x + y;
    println!("{}", z);
}
"#;

        let findings = analyzer
            .analyze(Path::new("similar.rs"), identical_content.as_bytes())
            .unwrap();

        // Should detect high similarity
        if !findings.is_empty() {
            let finding = &findings[0];
            assert!(finding.message.contains("%"));
        }
    }

    #[test]
    fn test_min_lines_threshold() {
        let analyzer = DuplicateAnalyzer::new().with_min_lines(10);
        let short_duplicate = r#"
fn short_a() {
    println!("short");
}

fn short_b() {
    println!("short");
}
"#;

        let findings = analyzer
            .analyze(Path::new("short.rs"), short_duplicate.as_bytes())
            .unwrap();

        // Should not detect duplicates below minimum line threshold
        assert_eq!(findings.len(), 0);
    }

    #[test]
    fn test_file_type_support() {
        let analyzer = DuplicateAnalyzer::new();

        // Should support source code files
        assert!(analyzer.supports_file(Path::new("test.rs")));
        assert!(analyzer.supports_file(Path::new("test.js")));
        assert!(analyzer.supports_file(Path::new("test.py")));
        assert!(analyzer.supports_file(Path::new("test.java")));

        // Should not support non-source files
        assert!(!analyzer.supports_file(Path::new("test.txt")));
        assert!(!analyzer.supports_file(Path::new("test.md")));
        assert!(!analyzer.supports_file(Path::new("test.png")));
    }
}

#[cfg(test)]
mod integration_tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_analyzer_registry_integration() {
        // This test would require access to the analyzer registry
        // For now, we test that analyzers can be created and used independently

        let git_analyzer = GitConflictAnalyzer::new();
        let ai_analyzer = AiContentAnalyzer::new();
        let dup_analyzer = DuplicateAnalyzer::new();

        let test_content = b"fn main() { println!(\"test\"); }";
        let test_path = Path::new("test.rs");

        // All analyzers should be able to process the same file
        let git_findings = git_analyzer.analyze(test_path, test_content).unwrap();
        let ai_findings = ai_analyzer.analyze(test_path, test_content).unwrap();
        let dup_findings = dup_analyzer.analyze(test_path, test_content).unwrap();

        // Clean code should produce no findings
        assert_eq!(git_findings.len(), 0);
        assert_eq!(ai_findings.len(), 0);
        assert_eq!(dup_findings.len(), 0);
    }

    #[test]
    fn test_real_file_analysis() -> std::io::Result<()> {
        let temp_dir = TempDir::new()?;

        // Create a test file with various issues
        let test_file = temp_dir.path().join("problematic.rs");
        let content = r#"
// Generated by AI assistant
fn main() {
    println!("Starting app");

<<<<<<< HEAD
    let config = load_config_v1();
=======
    let config = load_config_v2();
>>>>>>> feature

    // TODO: implement proper error handling
    do_something();
}

fn do_something() {
    // add content here
    unimplemented!()
}

fn authenticate_user(user: &str, pass: &str) -> bool {
    let hash = simple_hash(pass);
    hash == "expected"
}

fn authenticate_admin(user: &str, pass: &str) -> bool {
    let hash = simple_hash(pass);
    hash == "expected"
}

fn simple_hash(input: &str) -> &'static str {
    "hashed"
}
"#;

        fs::write(&test_file, content)?;

        // Test each analyzer
        let git_analyzer = GitConflictAnalyzer::new();
        let ai_analyzer = AiContentAnalyzer::new();
        let dup_analyzer = DuplicateAnalyzer::new().with_min_lines(3);

        let file_content = fs::read(&test_file)?;

        let git_findings = git_analyzer.analyze(&test_file, &file_content).unwrap();
        let ai_findings = ai_analyzer.analyze(&test_file, &file_content).unwrap();
        let dup_findings = dup_analyzer.analyze(&test_file, &file_content).unwrap();

        // Should detect git conflicts
        assert!(!git_findings.is_empty());
        assert!(git_findings.iter().any(|f| f.analyzer == "git_conflict"));

        // Should detect AI content and placeholders
        assert!(!ai_findings.is_empty());
        assert!(ai_findings.iter().any(|f| f.analyzer == "ai_content"));

        // Should detect duplicate authentication functions
        assert!(!dup_findings.is_empty());
        assert!(dup_findings.iter().any(|f| f.analyzer == "duplicate"));

        Ok(())
    }

    #[test]
    fn test_performance_with_large_content() {
        use std::time::Instant;

        // Generate large content
        let mut large_content = String::new();
        for i in 0..1000 {
            large_content.push_str(&format!(
                "fn function_{}() {{\n    println!(\"Function {}\");\n}}\n\n",
                i, i
            ));
        }

        let analyzers = vec![
            Box::new(GitConflictAnalyzer::new()) as Box<dyn Analyzer>,
            Box::new(AiContentAnalyzer::new()) as Box<dyn Analyzer>,
            Box::new(DuplicateAnalyzer::new()) as Box<dyn Analyzer>,
        ];

        for analyzer in analyzers {
            let start = Instant::now();
            let _findings = analyzer
                .analyze(Path::new("large_test.rs"), large_content.as_bytes())
                .unwrap();
            let duration = start.elapsed();

            // Should complete within reasonable time (adjust threshold as needed)
            assert!(
                duration.as_secs() < 5,
                "Analyzer {} took too long: {:?}",
                analyzer.name(),
                duration
            );
        }
    }
}
