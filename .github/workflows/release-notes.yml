name: Release Notes Automation

on:
  release:
    types: [published]

jobs:
  update-release-notes:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for changelog generation

      - name: Generate Release Notes
        id: generate-notes
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            
            // Get current release info
            const release = context.payload.release;
            const currentTag = release.tag_name;
            
            // Get previous release tag
            const previousTag = execSync('git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo ""', { encoding: 'utf8' }).trim();
            
            if (!previousTag) {
              console.log('No previous tag found, skipping changelog generation');
              return;
            }
            
            // Get PRs merged between tags
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              sort: 'updated',
              direction: 'desc',
              per_page: 100
            });
            
            // Filter PRs merged between previous and current tag
            const mergedPRs = prs.data.filter(pr => 
              pr.merged_at && 
              pr.merged_at > new Date(previousTag) && 
              pr.merged_at <= new Date(release.published_at)
            );
            
            // Categorize PRs by labels
            const categories = {
              'ðŸš€ Features': [],
              'ðŸ› Bug Fixes': [],
              'ðŸ”’ Security': [],
              'ðŸ“š Documentation': [],
              'ðŸ”§ Maintenance': [],
              'âš¡ Performance': [],
              'ðŸ§ª Testing': [],
              'ðŸ”„ Refactoring': [],
              'ðŸ“¦ Dependencies': []
            };
            
            mergedPRs.forEach(pr => {
              let categorized = false;
              pr.labels.forEach(label => {
                const labelName = label.name.toLowerCase();
                if (labelName.includes('feature') || labelName.includes('enhancement')) {
                  categories['ðŸš€ Features'].push(pr);
                  categorized = true;
                } else if (labelName.includes('bug') || labelName.includes('fix')) {
                  categories['ðŸ› Bug Fixes'].push(pr);
                  categorized = true;
                } else if (labelName.includes('security')) {
                  categories['ðŸ”’ Security'].push(pr);
                  categorized = true;
                } else if (labelName.includes('documentation') || labelName.includes('docs')) {
                  categories['ðŸ“š Documentation'].push(pr);
                  categorized = true;
                } else if (labelName.includes('performance') || labelName.includes('perf')) {
                  categories['âš¡ Performance'].push(pr);
                  categorized = true;
                } else if (labelName.includes('test')) {
                  categories['ðŸ§ª Testing'].push(pr);
                  categorized = true;
                } else if (labelName.includes('refactor')) {
                  categories['ðŸ”„ Refactoring'].push(pr);
                  categorized = true;
                } else if (labelName.includes('dependencies') || labelName.includes('deps')) {
                  categories['ðŸ“¦ Dependencies'].push(pr);
                  categorized = true;
                }
              });
              
              // If not categorized, put in maintenance
              if (!categorized) {
                categories['ðŸ”§ Maintenance'].push(pr);
              }
            });
            
            // Generate markdown
            let notes = `# Release ${currentTag}\n\n`;
            notes += `**Full Changelog**: https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${previousTag}...${currentTag}\n\n`;
            
            for (const [category, prList] of Object.entries(categories)) {
              if (prList.length > 0) {
                notes += `## ${category}\n\n`;
                prList.forEach(pr => {
                  notes += `- ${pr.title} (#${pr.number}) by @${pr.user.login}\n`;
                });
                notes += '\n';
              }
            }
            
            // Set output for next step
            core.setOutput('release-notes', notes);

      - name: Update Release Notes
        run: |
          NOTES="${{ steps.generate-notes.outputs.release-notes }}"
          if [ -n "$NOTES" ]; then
            gh release edit ${{ github.event.release.tag_name }} --notes "$NOTES"
          else
            echo "No notes generated, skipping update"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
